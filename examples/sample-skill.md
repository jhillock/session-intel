# Sample Skill: react-component-patterns

This is an example of a well-structured skill generated by Session Intelligence.

---

## SKILL.md Content

```markdown
---
name: react-component-patterns
description: Common React component patterns for composition and reusability
tags: [react, components, composition, typescript]
---

# React Component Patterns

Use these patterns when building React components to avoid common mistakes and improve code quality.

## When to Use This Skill

**Triggers:**
- Building new React components
- Refactoring existing components
- Component becoming too complex (>200 lines, multiple concerns)
- Props drilling through 3+ levels
- Need to share logic between components

## Common Patterns

### 1. Compound Components

**Use when:** A component has multiple related parts that work together.

**Example:** Tabs, Accordion, Dropdown

❌ **Bad (Prop Hell):**
```typescript
<Tabs
  tab1Label="Profile"
  tab1Content={<Profile />}
  tab2Label="Settings"
  tab2Content={<Settings />}
  tab3Label="Billing"
  tab3Content={<Billing />}
/>
```

✅ **Good (Compound Components):**
```typescript
<Tabs defaultValue="profile">
  <TabsList>
    <TabsTrigger value="profile">Profile</TabsTrigger>
    <TabsTrigger value="settings">Settings</TabsTrigger>
    <TabsTrigger value="billing">Billing</TabsTrigger>
  </TabsList>
  <TabsContent value="profile"><Profile /></TabsContent>
  <TabsContent value="settings"><Settings /></TabsContent>
  <TabsContent value="billing"><Billing /></TabsContent>
</Tabs>
```

**Implementation:**
```typescript
import { createContext, useContext, useState } from 'react';

type TabsContextType = {
  activeTab: string;
  setActiveTab: (tab: string) => void;
};

const TabsContext = createContext<TabsContextType | null>(null);

export function Tabs({ 
  children, 
  defaultValue 
}: { 
  children: React.ReactNode; 
  defaultValue: string;
}) {
  const [activeTab, setActiveTab] = useState(defaultValue);
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  );
}

export function TabsList({ children }: { children: React.ReactNode }) {
  return <div role="tablist">{children}</div>;
}

export function TabsTrigger({ 
  value, 
  children 
}: { 
  value: string; 
  children: React.ReactNode;
}) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsTrigger must be used within Tabs');
  
  return (
    <button
      role="tab"
      aria-selected={context.activeTab === value}
      onClick={() => context.setActiveTab(value)}
    >
      {children}
    </button>
  );
}

export function TabsContent({ 
  value, 
  children 
}: { 
  value: string; 
  children: React.ReactNode;
}) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsContent must be used within Tabs');
  
  if (context.activeTab !== value) return null;
  return <div role="tabpanel">{children}</div>;
}
```

---

### 2. Render Props Pattern

**Use when:** You need to share stateful logic but the rendered output varies.

❌ **Bad (Duplicate Logic):**
```typescript
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser().then(setUser).finally(() => setLoading(false));
  }, []);
  
  if (loading) return <Spinner />;
  return <div>{user.name}</div>;
}

function UserAvatar() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser().then(setUser).finally(() => setLoading(false));
  }, []);
  
  if (loading) return <Spinner />;
  return <img src={user.avatar} />;
}
```

✅ **Good (Render Props):**
```typescript
function WithUser({ 
  children 
}: { 
  children: (user: User | null, loading: boolean) => React.ReactNode;
}) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser().then(setUser).finally(() => setLoading(false));
  }, []);
  
  return <>{children(user, loading)}</>;
}

// Usage
<WithUser>
  {(user, loading) => {
    if (loading) return <Spinner />;
    return <div>{user.name}</div>;
  }}
</WithUser>

<WithUser>
  {(user, loading) => {
    if (loading) return <Spinner />;
    return <img src={user.avatar} />;
  }}
</WithUser>
```

---

### 3. Custom Hooks (Extract Logic)

**Use when:** Same logic needed in multiple components.

❌ **Bad (Inline Logic):**
```typescript
function ProductList() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(setProducts)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);
  
  // ... render
}
```

✅ **Good (Custom Hook):**
```typescript
function useProducts() {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch');
        return res.json();
      })
      .then(setProducts)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);
  
  return { products, loading, error };
}

// Usage
function ProductList() {
  const { products, loading, error } = useProducts();
  
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  return <div>{products.map(p => <ProductCard key={p.id} {...p} />)}</div>;
}
```

---

### 4. Container/Presenter Pattern

**Use when:** Separate data fetching from presentation.

✅ **Container (Logic):**
```typescript
function UserProfileContainer({ userId }: { userId: string }) {
  const { user, loading, error } = useUser(userId);
  
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return <NotFound />;
  
  return <UserProfilePresenter user={user} />;
}
```

✅ **Presenter (UI Only):**
```typescript
type UserProfilePresenterProps = {
  user: User;
};

function UserProfilePresenter({ user }: UserProfilePresenterProps) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.bio}</p>
      <img src={user.avatar} alt={user.name} />
    </div>
  );
}
```

**Benefits:**
- Presenter is pure (no side effects) → easy to test
- Container handles all data/loading/error logic
- Presenter can be used in Storybook independently

---

## Component Size Guidelines

**Too small:** Single-use wrappers, one-line components  
**Too large:** >200 lines, multiple concerns

**Ideal size:** 50-150 lines, single responsibility

**Refactor signals:**
- Scrolling to find related code
- Hard to name the component (doing too much)
- Many useState calls (complex state → useReducer)
- Passing 5+ props (consider composition)

---

## Props Best Practices

### Use Discriminated Unions for Variants

❌ **Bad (Optional Props Hell):**
```typescript
type ButtonProps = {
  variant?: 'primary' | 'secondary' | 'link';
  href?: string;       // Only for link
  onClick?: () => void; // Only for button
  disabled?: boolean;  // Only for button
};
```

✅ **Good (Discriminated Union):**
```typescript
type ButtonProps = 
  | {
      variant: 'primary' | 'secondary';
      onClick: () => void;
      disabled?: boolean;
    }
  | {
      variant: 'link';
      href: string;
    };
```

TypeScript now enforces: `variant="link"` requires `href`, not `onClick`.

---

### Avoid Boolean Props for Variants

❌ **Bad:**
```typescript
<Button primary secondary large small />
```

✅ **Good:**
```typescript
<Button variant="primary" size="large" />
```

---

## Testing Patterns

### Test Presenters Independently

```typescript
import { render, screen } from '@testing-library/react';
import { UserProfilePresenter } from './UserProfilePresenter';

const mockUser: User = {
  id: '1',
  name: 'Alice',
  bio: 'Developer',
  avatar: '/avatar.jpg',
};

test('renders user name', () => {
  render(<UserProfilePresenter user={mockUser} />);
  expect(screen.getByText('Alice')).toBeInTheDocument();
});
```

### Test Containers with Mocked Hooks

```typescript
import { render, screen } from '@testing-library/react';
import { UserProfileContainer } from './UserProfileContainer';
import { useUser } from './useUser';

jest.mock('./useUser');

test('shows spinner while loading', () => {
  (useUser as jest.Mock).mockReturnValue({ 
    user: null, 
    loading: true, 
    error: null 
  });
  
  render(<UserProfileContainer userId="1" />);
  expect(screen.getByRole('status')).toBeInTheDocument();
});
```

---

## Common Mistakes to Avoid

### 1. Prop Drilling
**Problem:** Passing props through 3+ levels

**Solution:** Context, Compound Components, or state management (Zustand, Jotai)

### 2. Massive Components
**Problem:** 300+ line components doing everything

**Solution:** Extract custom hooks, split into Container/Presenter

### 3. Inline Event Handlers
**Problem:** Creates new function every render

❌ **Bad:**
```typescript
<button onClick={() => handleClick(item.id)}>Click</button>
```

✅ **Good:**
```typescript
const handleItemClick = useCallback(() => handleClick(item.id), [item.id]);
<button onClick={handleItemClick}>Click</button>
```

### 4. Missing Keys in Lists
**Problem:** React can't track items, causes re-renders

❌ **Bad:**
```typescript
{items.map((item, index) => <Item key={index} {...item} />)}
```

✅ **Good:**
```typescript
{items.map(item => <Item key={item.id} {...item} />)}
```

---

## Related Skills

- `react-state-patterns.md` - useState vs useReducer vs Context
- `react-hooks-patterns.md` - useEffect, useMemo, useCallback
- `react-performance.md` - Optimization techniques

---

## References

- [React Docs: Patterns](https://react.dev/learn/passing-props-to-a-component)
- [Kent C. Dodds: Advanced React Patterns](https://kentcdodds.com/blog/advanced-react-component-patterns)
- [Radix UI: Composition patterns](https://www.radix-ui.com/)

---

*This skill was generated by Session Intelligence based on patterns detected in 12 sessions with high struggle in React component structure.*
```

---

## Notes on This Example

### What Makes This a Good Skill

1. **Clear triggers** - Specific conditions when to use it
2. **Before/after examples** - Shows wrong way and right way
3. **Multiple patterns** - Covers related concepts (compound components, render props, custom hooks)
4. **TypeScript** - Type-safe examples
5. **Testing guidance** - How to validate the patterns work
6. **Common mistakes** - Explicitly calls out what NOT to do
7. **Related skills** - Links to other relevant skills
8. **References** - External resources for deeper learning

### What Was Extracted from Sessions

This skill was generated after detecting:
- **8 sessions** with React component struggles
- **User corrections** about prop drilling, component size
- **Retry chains** where Claude rewrote components multiple times
- **Error patterns** around missing keys, inline handlers

### Effectiveness After Creation

After applying this skill:
- **Before:** 8 sessions, avg struggle 32.1
- **After:** 12 sessions, avg struggle 14.2
- **Reduction:** 56% (EFFECTIVE)
- **Usage:** 10/12 sessions (83%)

---

*Use this as a template for creating your own skills manually or reviewing AI-generated ones.*
